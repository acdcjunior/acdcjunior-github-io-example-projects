<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
     					http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
						http://www.springframework.org/schema/jdbc
						http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">

   	<bean id="pilotoDataSource" class="net.acdcjunior.piloto.test.util.TestDataSource">
   	</bean>
   	
   	<!--
   	A configuracao abaixo, que ja vem com o Spring, poderia ser usada (o que tornaria
   	a classe TestDataSource desnecessaria).
   	Essa configuracao cria um banco embarcado H2 para os testes (como o TestDataSource).
   	
   	A diferenca, e que me fez optar por criar a TestDataSource, eh que a jdbc:embedded-database
   	nao recria (isto eh, nao apaga a base e re-executa os scripts) a cada teste, o que faz com
   	que as alteracoes (dados inseridos/removidos) de um teste sejam levadas para outros testes.
   	
   	O TestDataSource nao faz isso: toda execucao de metodo eh feita em uma base nova, do zero.
   	Com relacao ao tempo, ainda, o TestDataSource eh 0.2s mais rapido.
   	 -->
	<!--
	<jdbc:embedded-database id="pilotoDataSource" type="H2">
	    <jdbc:script location="classpath:esquema.sql" />
	    <jdbc:script location="classpath:dadosDeTeste.sql" />
	</jdbc:embedded-database>
	-->

</beans>